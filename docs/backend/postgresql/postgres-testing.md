# Postgres testing

## Mock database vs real database

If we are writing unit tests, by definition we need to mock the interaction with database and we don't depend on a real database.

For integration test/contract test (e.g. on web service built using Express + Postgres), we need to get the server up and running before we can send requests to it. Most of the time, that would require us to have a real database.

If somehow your tests need to depend on a real database, you need to make sure each test case has a clean database to start with. One solution is to set up and tear down all the tables in the database to ensure there are no side effects between unit tests. In practice, this means a `beforeEach()` where you reconnect to the database and drop all tables, and an `afterEach()` where you disconnect from the database.

Another solution is to set up an **in-memory database** for each test case programmatically to avoid some of the issues with setting up a real database and sharing one database with all tests.

## sequelize-mock-v5: Mocking library for Sequelize

[Sequelize Mock](https://sequelize-mock.readthedocs.io/en/stable/) or [sequelize-mock-v5](https://www.npmjs.com/package/sequelize-mock-v5) is a mocking library for Sequelize. Mock objects created with this library are meant for use in testing code that relies on Sequelize Models. Code does not rely on any database connections and can therefore be easily used in unit and integration tests without requiring the setup of a test database system.

For unit testing Sequelize, mocking models becomes essential — Sequelize Mock offers decent capabilities like mimicking models as well as mocking many if not all Sequelize methods. Reference: https://medium.com/@kvr2277/sequelize-mocking-with-jest-and-node-933c1f439579

For integration test / contract testing, we could occasionally avoid the need to maintain a real database with Sequelize Mock. Since we generated models using Sequelize, sequelize-mock offers excellent mocking capabilities using which we can mock models and proceed with testing our core functionalities. The benefit of doing so:
1. No actual database calls invoked for every test run. Tests could be completed in shorter time and with lower maintenance cost.
2. With actual database involved for testing, data can change in database and your tests are prone to fail for influences outside your code.
**Caveats:** Since the database layer is already abstracted by the ORM, it's important to ensure the functionalities of the ORM mocking library is actually up-to-date with the ORM library.

## pg-mem

Usage of **in-memory database** offers us a clean/empty database for each test case, so that the test cases do not interfere with each other (e.g. if a test case fails and leave some garbage data in its copy of database, that failure will not affect other test cases because each test case starts with a clean database).

To write API integration tests for an Express app that uses Postgres as the database, we could choose to use `pg-mem` along with `jest` and `supertest`. It spins up an in-memory instance of a Postgres database, which is faster than running a separate Postgres instance. The library provides handy shortcuts to create instances of popular libraries that will be bound to pg-mem instead of a real postgres db.

Some of the popular library adapters that shipped with **pg-mem** includes:
- [node-postgres (pg)](https://github.com/oguimbal/pg-mem/wiki/Libraries-adapters#-node-postgres-pg)
- [TypeORM](https://github.com/oguimbal/pg-mem/wiki/Libraries-adapters#-typeorm)
- [Knex](https://github.com/oguimbal/pg-mem/wiki/Libraries-adapters#-knex)

Although there isn't any direct support for testing `sequelize` ORM with Postgres, we could extend the usage of `pg-mem` since sequelize is using `pg` as the underlying Postgres client.

## Jest Expect Function

For testing database, very often we will use `toMatchObject`. This is because the database objects will have the extra attribute `id`.
https://stackoverflow.com/questions/45692456/whats-the-difference-between-tomatchobject-and-objectcontaining

[Manual mocks](https://jestjs.io/docs/manual-mocks) are used to stub out functionality with mock data.

[Snapshots tests](https://jestjs.io/docs/snapshot-testing) are a fantastic tool for identifying unexpected interface changes within your application – whether that interface is an API response, UI, logs, or error messages. Snapshot files are generated by Jest the first time it's running the test, and prevent accidental update of the test expectation. As with any testing strategy, there are some [best-practices](https://jestjs.io/docs/snapshot-testing#best-practices). The aim of snapshot testing is not to replace existing unit tests, but to provide additional value and make testing painless. Jest allows providing an asymmetric matcher `.toMatchSnapshot(propertyMatchers?, hint?)` for any property. We could use [Property Matchers](https://jestjs.io/docs/snapshot-testing#property-matchers) in the snapshot files to avoid failure due to generated fields.

## Unit Testing with Jest and SuperTest
Mocking is important technique to perform unit test or integration test.

In this example, we will mock out the sequelize model to perform unit test for the Express router. Do note that this doesn't test the Sequelize Model and testing Sequelize library is usually out-of-scope.
To perform integration test between Express router and Sequelize model without real database, you may consider using `sequelize-mock` instead.

These documentations could be helpful for mocking, as well as testing NodeJS ES6 modules.
- [Notes for Javascipt Mocks](https://thoughtworks-sea.github.io/developer-training/#/javascript/mocks)
- [Jest Mock Functions](https://jestjs.io/docs/mock-functions)
- [Jest Manual mocking with ES6](https://jestjs.io/docs/manual-mocks#using-with-es-module-imports)
- [Jest ships with experimental support for ECMAScript Modules (ESM)](https://jestjs.io/docs/ecmascript-modules).

Before writing any test, we set up the dependencies.
```
npm install --save-dev jest supertest
```

Configure `package.json` for ES6 support.
```json
  "scripts": {
    "test": "NODE_OPTIONS=--experimental-vm-modules jest",
    "test:watch": "NODE_OPTIONS=--experimental-vm-modules jest --watch"
  },
```

Notable Issues on Jest with ECMAScript:
- [Meta: Native support for ES Modules](https://github.com/facebook/jest/issues/9430)
- [jest.mock does not mock an ES module without Babel](https://github.com/facebook/jest/issues/10025)
- [To disable any source code transformations in Jest](https://stackoverflow.com/questions/64582674/jest-mock-of-es6-class-yields-referenceerror-require-is-not-defined)

Then, you will need to create express router for all the CRUD functions, as well as to do some refactoring to support dependency injection.

`__tests__/pokemon.route.test.js`

```javascript
import express from 'express';
import request from 'supertest';

import { jest } from '@jest/globals'; // ES6 support

import pokemonRouter, { mockPokemonModel } from '../routes/pokemon.route.js';

jest.setTimeout(3000);
// jest.useFakeTimers();

// https://medium.com/@kvr2277/sequelize-mocking-with-jest-and-node-933c1f439579
// import SequelizeMock from 'sequelize-mock-v5';
// const mockDb = new SequelizeMock();

const myMockFn = jest.fn;

const pokemon1 = {
  id: 1,
  name: 'Pikachu',
  japaneseName: 'ピカチュウ',
  baseHP: 35,
  category: 'Mouse Pokemon'
};

jest.mock('../db/models/simple-pokemon.model.js');

const app = express();
app.use('/', pokemonRouter());
// app.use("/", pokemonRouter(mockDb));d

describe('/pokemon', () => {
  const mockPokemon1 = {
    ...pokemon1,
    toJSON: myMockFn(() => pokemon1)
  };

  // https://medium.com/@kvr2277/sequelize-mocking-with-jest-and-node-933c1f439579
  // https://github.com/facebook/jest/issues/10025
  beforeAll(async () => {
    mockPokemonModel({
      findAll: () => [pokemon1],
      create: async (ignore) => mockPokemon1
    });
  });

  describe('GET /all', () => {
    it('should return all pokemons', async () => {
      const response = await request(app).get('/all').expect(200);

      const { body } = response;
      expect(body.length).toEqual(1);
      expect(body[0]).toMatchObject(pokemon1);
    });
  });

  describe('POST /new', () => {
    it('should create and return the new pokemons', async () => {
      const requestCreatePokemon1 = JSON.stringify({
        ...pokemon1,
        id: null
      });
      const response = await request(app).post('/new').send(requestCreatePokemon1);

      expect(response.status).toEqual(200);

      const { body } = response;
      expect(body.id).toEqual(1);
      expect(body).toMatchObject(pokemon1);
    });
  });
});
```

**Refactoring source code for dependency injection**

`simple-pokemon.model.js`: We will modify the database model to accept database connection as a dependency. This could be done by moving all the main functions (ie. `SimplePokemon.init()` and model synchronisation) into the `export default` statement,

```javascript
import sequelizeConnection from '../../utils/db.js'; // Reference to the database connection instance
/*
  We need to destruct exports from sequelize due to limited support on ESM of jest.
  - https://jestjs.io/docs/ecmascript-modules
  - https://stackoverflow.com/questions/47277887/node-experimental-modules-requested-module-does-not-provide-an-export-named
*/
// import { DataTypes, Model } from 'sequelize';
import sequelize from 'sequelize';
const { DataTypes, Model } = sequelize;

class SimplePokemon extends Model { };

// previous
// import sequelizeConnection from '../../utils/db.js'; // no longer required, since we inject dependency
// SimplePokemon.init(...); // Simplified for readability
//
// const synchronizeModel = async () => await SimplePokemon.sync({ force: true });
// await synchronizeModel();
//
// export default SimplePokemon;

// now
export default async (dbConnection) => {
  SimplePokemon.init(...); // Simplified for readability

  const synchronizeModel = async () => await SimplePokemon.sync({ force: true });
  await synchronizeModel();

  return SimplePokemon;
};
```

`pokemon.route.js`: Since we are mocking out the Sequelize model, we will need to modify the router to
1. In all situation except test environment, Router will have reference to the actual Sequelize Model, which requires attempt for a database connection.
1. For testing environment, accept a mock instance of the model and does not attempt to perform database connection. **Reason: The Sequelize Model#init will fails without an actual database connection**

```javascript
import express from 'express';

import dbConnection from '../db.js';

import InitSimplePokemon from '../db/models/simple-pokemon.model.js';
let SimplePokemon; // Router is heavily depends on the Sequelize/Mock Model, this statement allow us to inject the model into router after initialization.

const router = express.Router();
router.use(express.json());

router.get('/', ...); // simplified for readability
router.post('/', ...); // simplified for readability

export default () => {
  return router;
};

// These functions need to be invoked before running any test.
// To initialize the model and set the dependency for use of router.
export const mockPokemonModel = (mockModel) => {
  SimplePokemon = mockModel; // This doesn't require database connection
};

// These functions need to be invoked before serving traffic in the application environments.
// To initialize the model and set the dependency for use of router.
export const initPokemonModel = async () => {
  SimplePokemon = await InitSimplePokemon(dbConnection); // This need to have database connection as pre-requisite
};
```

## Exercises

- Complete the unit test for SimplePokemon CRUD routes.
- Create integration testing with Sequelize Mock for SimplePokemon CRUD routes, to test business logic.
- Integrate Postgres into your testing for your song routes.
