# Postgres testing

## Mock database vs real database

If we are writing unit tests, by definition we need to mock the interaction with database and we don't depend on a real database.

For integration test/contract test (e.g. on web service built using Express + Postgres), we need to get the server up and running before we can send requests to it. Most of the time, that would require us to have a real database.

If somehow your tests need to depend on a real database, you need to make sure each test case has a clean database to start with. One solution is to set up and tear down all the tables in the database to ensure there are no side effects between unit tests. In practice, this means a `beforeEach()` where you reconnect to the database and drop all tables, and an `afterEach()` where you disconnect from the database.

Another solution is to set up an **in-memory database** for each test case programmatically to avoid some of the issues with setting up a real database and sharing one database with all tests.

## sequelize-mock-v5: Mocking library for Sequelize

[Sequelize Mock](https://sequelize-mock.readthedocs.io/en/stable/) or [sequelize-mock-v5](https://www.npmjs.com/package/sequelize-mock-v5) is a mocking library for Sequelize. Mock objects created with this library are meant for use in testing code that relies on Sequelize Models. Code does not rely on any database connections and can therefore be easily used in unit and integration tests without requiring the setup of a test database system.

For unit testing Sequelize, mocking models becomes essential — Sequelize Mock offers decent capabilities like mimicking models as well as mocking many if not all Sequelize methods. Reference: https://medium.com/@kvr2277/sequelize-mocking-with-jest-and-node-933c1f439579

For integration test / contract testing, with Sequelize Mock, we could avoid the need to maintain a real database. The benefit of doing so:
1. No actual database calls invoked for every test run. Tests could be completed in shorter time and with lower maintenance cost.
2. With actual database involved for testing, data can change in database and your tests are prone to fail for influences outside your code.

Since we generated models using Sequelize, sequelize-mock offers excellent mocking capabilities using which we can mock models and proceed with testing our core functionalities.

**Caveats:** Since the database layer is already abstracted by the ORM, it's important to ensure the functionalities of the ORM mocking library is actually up-to-date with the ORM library.

## pg-mem

To write API tests for an Express app that uses Postgres as the database, we are going to use a library called **pg-mem**. It spins up an in-memory instance of a Postgres database, which is faster than running a separate Postgres instance.

The library helps to give us a clean/empty database for each test case, so that the test cases do not interfere with each other (e.g. if a test case fails and leave some garbage data in its copy of database, that failure will not affect other test cases because each test case starts with a clean database).

Thus along with jest and supertest, we will need pg-mem.

```sh
npm install pg-mem --save-dev
```

Before writing any test...

<!-- TODO: example of setting up and tearing down db in beforeEach/afterEach -->

```
WIP
```

First test for GET `/pokemons`

<!-- TODO: example of GET test with .toMatchObject -->

```
WIP
```

## Jest Expect Function

For testing database, very often we will use `toMatchObject`. This is because the database objects will have the extra attribute `id`.
https://stackoverflow.com/questions/45692456/whats-the-difference-between-tomatchobject-and-objectcontaining

[Manual mocks](https://jestjs.io/docs/manual-mocks) are used to stub out functionality with mock data.

[Snapshots tests](https://jestjs.io/docs/snapshot-testing) are a fantastic tool for identifying unexpected interface changes within your application – whether that interface is an API response, UI, logs, or error messages. Snapshot files are generated by Jest the first time it's running the test, and prevent accidental update of the test expectation. As with any testing strategy, there are some [best-practices](https://jestjs.io/docs/snapshot-testing#best-practices). The aim of snapshot testing is not to replace existing unit tests, but to provide additional value and make testing painless. Jest allows providing an asymmetric matcher `.toMatchSnapshot(propertyMatchers?, hint?)` for any property. We could use [`Property Matchers`](https://jestjs.io/docs/snapshot-testing#property-matchers) in the snapshot files to avoid failure due to generated fields.

## Exercises

- Integrate Sequelize Mock into your testing for SimplePokemon CRUD routes.
- Integrate Postgres into your testing for your song routes.
