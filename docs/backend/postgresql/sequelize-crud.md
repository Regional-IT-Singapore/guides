# Sequelize CRUD

This page of notes is simplified from [Sequelize Core Concepts - Model Instances](https://sequelize.org/master/manual/model-instances.html). Please read the [Sequelize API Reference](https://sequelize.org/master/class/lib/model.js~Model.html) for more details.

## Pre-requisite
Assuming that you followed the notes in [Sequelize Basics](https://thoughtworks-sea.github.io/developer-training/#/backend/postgresql/sequelize-basics?id=create-a-simple-model), you should have created the `SimplePokemon` model for and acquired a database connection instance.

Alternatively, a model could be generated using `sequelize-cli`. This will generate different folder structure. However, [Migrations](https://sequelize.org/master/manual/migrations.html#project-bootstrapping) is another topic, which is recommended for production level software, however it requires manual configuration.
```sh
npx sequelize-cli init
npx sequelize-cli model:generate --name SimplePokemon --attributes name:string,japaneseName:string,baseHP:integer,category:string,nameWithJapanese:virtual
```
## Independent Imports of Sequelize Models

In practice, we might need to import the models into multiple javascript controllers. Imagine we are developing an app for pokemon trainer, `SimplePokemon` will be required in `PokemonRouter` and `TrainerRouter`. So it is important to make sure that the multiple import of the models will not cause any destructive operation to the actual database table, ie. `sequelize.sync` or `model.sync` should not be defined in individual model files.

From the previous model, you see that the model is dependent on the database connection instance, right? By removing this dependency, we could then import the `SimplePokemon` model multiple javascript files safely.

Here described the refactoring that required. We will talk about the migration tool next time.

1. Replacing `db/index.js` with `db/model/index.js` (a piece of code that could be generated by the `sequelize-cli` migration tools). The file `db/model/index.js` contains the logic to associate sequelize connection instance to all the models in the folder. _Remember to replace the references to db/index.js everywhere, and clean up the unused file!_

2. Replace the code in `simple-pokemon.model.js`. The new codes are boilerplate generated by the `sequelize-cli` migration tools, and moved our attribute definition into the boilerplate.

3. In `index.js`, we will request sequelize to synchronize all the models at once (when the application starts). And import the models.


```js
// db/model/index.js
'use strict';

const fs = require('fs');
const path = require('path');
const Sequelize = require('sequelize');
const basename = path.basename(__filename);
const env = process.env.NODE_ENV || 'development';
const config = require(__dirname + '/../../config/database.js')[env];
const db = {};

let sequelize;
if (config.use_env_variable) {
  sequelize = new Sequelize(config.use_env_variable, config); // slight adjustment from sequelize-cli output
} else {
  sequelize = new Sequelize(config.database, config.username, config.password, config);
}

fs
  .readdirSync(__dirname)
  .filter(file => {
    return (file.indexOf('.') !== 0) && (file !== basename) && (file.slice(-3) === '.js');
  })
  .forEach(file => {
    const model = require(path.join(__dirname, file))(sequelize, Sequelize.DataTypes);
    db[model.name] = model;
  });

Object.keys(db).forEach(modelName => {
  if (db[modelName].associate) {
    db[modelName].associate(db);
  }
});

db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;
```

```js
// simple-pokemon.model.js

'use strict';
const { Model } = require('sequelize');

module.exports = (sequelize, DataTypes) => {
  class SimplePokemon extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
    }
  };
  SimplePokemon.init({
    name: {
      type: DataTypes.STRING,
    },
    japaneseName: {
      type: DataTypes.STRING,
    },
    baseHP: {
      type: DataTypes.INTEGER,
    },
    category: {
      type: DataTypes.STRING,
    },
    nameWithJapanese: {
      type: DataTypes.VIRTUAL,
      get() {
        return `${this.name} ${this.japaneseName}`;
      },
      set(value) {
        throw new Error("Do not try to set the `nameWithJapanese` value!");
      },
    },
  }, {
    sequelize,
    modelName: 'SimplePokemon',
  });
  return SimplePokemon;
};
```

```js
// index.js
const db = require('./db/models/index.js'); // --> REPLACE THIS

// [1] Just test connection, we don't neeed this in actual. --> REMOVE THIS SECTION
// [2] For dev exploration convenience, we forced synchronisation.
db.sequelize.sync({ force: true }); // --> REPLACE THIS
// db.sequelize.sync(); // --> REPLACE THIS

// [3] Use this syntax to refer to the model in the app/router code later --> ADDED THIS SECTION
// const SimplePokemon = await db.SimplePokemon.create();
```

## Create

Although a model is an ES6 class, you should not create instances by using the `new` operator directly. Instead, Sequelize Model exposes 2 methods for specific process.
- [build](https://sequelize.org/master/class/lib/model.js~Model.html#static-method-build): class-level method to create an object that represents data that can be mapped to a database record. This is a synchronous method that does not communicate with the database at all.
- [save](https://sequelize.org/master/class/lib/model.js~Model.html#instance-method-save): instance-level method to save / persist the information into database. This is an asynchronous method, so you will need `await` or promise handling.

To facilitate the process, Sequelize Model offers another method to combines the above 2 into a single method.
- [create](https://sequelize.org/master/class/lib/model.js~Model.html#static-method-create): class-level method to create an object and save the database record. This is an asynchronous method, so you will need `await` or promise handling.

Use `Model#create` static method to create a new instance and save the record into the database table `Simple_Pokemon`.

Update your `index.js` and create `crud/create.js`.

```js
// index.js
const db = require('./db/models/index.js');

const createPikachu = require('./crud/create'); //  --> ADDED THIS

// [1] Just test connection, we don't neeed this in actual.
// [2] For dev exploration convenience, we forced synchronisation.
db.sequelize.sync({ force: true });
// db.sequelize.sync();

// [3] Use this to refer to the model in the app/router code later
// const SimplePokemon = await db.SimplePokemon.create();

// [4] Set timeout to simulate async calls to play with model --> ADDED THIS SECTION
// We need to hold a while for db sync
setTimeout(createPikachu, 500);
```

```js
// crud/create.js
const db = require('../db/models/index.js');

const createPikachu = async () => {

  const pikachu = {
    name: "Pikachu",
    japaneseName: "ピカチュウ",
    baseHP: 35,
    category: "Mouse Pokemon",
  };
  console.log("HERE");
  const created = await db.SimplePokemon.create(pikachu);
  console.log("HERE");

  console.log('Pikachu was saved to the database!');
  // console.log(created); // Not recommended, since Sequelize instances have a lot of things attached. This might produce a lot of clutter.
  console.log(created.toJSON()); // The recommended way to log an instance, but do note that this might still log sensitive data stored in database. Need processing.
}

module.exports = createPikachu;
```

Upon a successful save, the result of the `create` method is a promise which resolves to the saved.

```json
{
    "nameWithJapanese": "Pikachu ピカチュウ",
    "id": 1,
    "name": "Pikachu",
    "japaneseName": "ピカチュウ",
    "baseHP": 35,
    "category": "Mouse Pokemon",
    "updatedAt": "2021-08-15T11:46:25.092Z",
    "createdAt": "2021-08-15T11:46:25.092Z"
}
```

Looking at the result, the following fields are returned in addition to the attributes that we've defined in the model and the information we passing in.
The additional fields are generated by Sequelize.
- `id`: Primary Key generated by Sequelize, if Primary Key is not defined.
- `createdAt`, `updatedAt`: This timestamp generated by Sequelize (by default) which could be turn off.

If you try to create another pokemon with the same `id` value,
```js
// Run this code after creation of pickachu.
  const pikachu2 = {
    id: 1,
    ...pikachu,
  }
  const created2 = await db.SimplePokemon.create(pikachu2)
  console.log(created2.toJSON());
```

you will find the application is hitting an error `UniqueConstraintError [SequelizeUniqueConstraintError]`.
```sh
  UniqueConstraintError [SequelizeUniqueConstraintError]: Validation error
  ...
  fields: { id: '1' },
  parent: error: duplicate key value violates unique constraint "Simple_Pokemon_pkey"
```

Change `id` to 2 and restart your application. You will find 2 identical pokemons in the database table `Simple_Pokemons` (both are having same attributes). This is because we didn't add any unique constraint onto the name column.

Let's try to update our model slightly.
1. Following the notes in [Sequelize Basics - More about Model Definition](backend/postgresql/sequelize-basics?id=more-about-model-definition).
In the example, we will add an unique index to the `name` field. Let's restart your application with the codes above to create 2 pokemons named `pikachu` with differrent `id`. What do you find?
1. Next, we explore [field validation](backend/postgresql/sequelize-basics?id=sequelize-validation) done by Sequelize.

You can try to create more pokemons with this stub data.

```js
const pokemons = [
  {
    name: 'Squirtle',
    japaneseName: 'ゼニガメ',
    baseHP: 44,
    category: 'Tiny Turtle Pokemon'
  },
  {
    name: 'Wartortle',
    japaneseName: 'カメール',
    baseHP: 59,
    category: 'Turtle Pokémon'
  },
  {
    name: 'Meowth',
    japaneseName: 'ニャース',
    baseHP: 40,
    category: 'Scratch Cat Pokémon'
  }
];
```

## Read

The returned result will be an array of Sequelize Model instances.

### FindAll

`findAll()` is the the main way we query the database with sequelize. The first parameter of find is a **options** object. Refer to the [API Reference](https://sequelize.org/master/class/lib/model.js~Model.html#static-method-findAll) for the list of supported options. If an empty object is passed or nothing is passed, then it will return all records.

Some notable options are grouped into:
- options for usual SQL query syntax
  - `where`
  - `order`
  - `having`
- additional options provided by Sequelize and translated into SQL query syntax
  - `attributes`
  - `include`: for list of associations to eagerly load using a left join.
  - `limit` and `offset`: for paginated result
  - `transaction`
  - `raw`: If true, sequelize will not try to format the results of the query, or build an instance of a model from the result. You are responsible to build the model.
  - `searchPath`: An optional parameter (string) to specify the [schema search_path (Postgres only)](https://www.postgresql.org/docs/current/ddl-schemas.html#DDL-SCHEMAS-PATH)
  - `rejectOnEmpty`: Throws an error when no records found. **Default: false**
- others (eg. for performance analysis)
  - `logging`
  - `benchmark`

#### Filtering Operators

In Sequelize, you can simply query with a powerful `where` clause. You can filter through Pokemon by their attributes, using `where`. Refer to [Querying Operators](https://sequelize.org/master/manual/model-querying-basics.html#operators).

https://sequelize.org/master/manual/model-querying-basics.html#postgres-only-range-operators
https://sequelize.org/master/manual/model-querying-basics.html#operators

We can use comparison operators `lt`, `gt`, `lte`, and `gte`.

Suppose you want to find characters whose category contains 'turtle'. In SQL, you would use the LIKE operator. Sequelize offers operators like `like`, `iLike`, `regexp`, `notRegexp`.

```js
// index.js
const Read = require('./crud/read');

setTimeout(() => Read.findPokemonsWithBaseHPGreaterThan(40), 500);
setTimeout(() => Read.findPokemonWithNameOrBaseHP('Pikachu', 59), 500);
```

```js
// crud/read.js
const db = require('../db/models/index.js');

const { Op } = require('sequelize');

const findPokemonsWithBaseHPGreaterThan = async (baseHP) => {
  const foundPokemons = await db.SimplePokemon.findAll({
    where: {
      baseHP: {
        [Op.gt]: baseHP
      }
    }
  });
  console.log(`RESULT FOR findPokemonsWithBaseHPGreaterThan: ${foundPokemons.length}`);
  console.log(foundPokemons);
  return foundPokemons;
};

const findPokemonWithNameOrBaseHP = async (name, baseHP) => {
  const foundPokemons = await db.SimplePokemon.findAll({
    where: {
      [Op.or]: [
        { name: name },
        { baseHP: baseHP }
      ]
    }
  });
  console.log(`RESULT FOR findPokemonWithNameOrBaseHP: ${foundPokemons.length}`);
  console.log(foundPokemons);
  return foundPokemons;
};

module.exports = {
  findPokemonsWithBaseHPGreaterThan,
  findPokemonWithNameOrBaseHP
};
```

## Update

The model static method `update()` update multiple instances that match the where options.

```js
// No returning records by default
const [numberOfAffectedRecords, updatedPokemons] = await db.SimplePokemon.update(
  { baseHP: 100 },                // target
  {                               // query option
    where: {
      category: {
        [Op.like]: '%Turtle%'
      }
    }
  }
);

// With updated records
const [numberOfAffectedRecords, updatedPokemons] = await db.SimplePokemon.update(
  { baseHP: 100 },                // target
  {                               // query option
    where: {
      category: {
        [Op.like]: '%Turtle%'
      }
    },
    returning: true // This will return updated result
  }
);
```

How to update just one pokemon? We could use [count()](https://sequelize.org/master/class/lib/model.js~Model.html#static-method-count) to validate first.
- Try running Sequelize with debug logging to see what queries Sequelize executes.

### update(), upsert(), save()

| Method           | Level          | Description                                                                                                                                                                                                                                                                                    |
| :--------------- | :------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `async update()` | Class-level    | Update multiple instances that match the where options. Each row is subject to validation before it is inserted. The whole insert will fail if one row fails validation.                                                                                                                       |
| `async upsert()` | Instance-level | This is the same as calling `set()` and then calling `save()` but it only saves the exact values passed to it, making it more atomic and safer.                                                                                                                                                |
| `async upsert()` | Class-level    | Insert or update a single row. An update will be executed if a row which matches the supplied values on either the primary key or a unique key is found. Requires the unique index to be defined in sequelize model as well as the database table. Run validations before the row is inserted. |
| `async save()`   | Instance-level | Validates this instance, and if the validation passes, persists it to the database. This method is optimized to perform an UPDATE only when the fields have changed. If nothing has changed, no SQL query will be performed. This method is not aware of eager loaded associations.            |

## Delete

The model static method `delete()` could delete multiple instances, or set their deletedAt timestamp to the current time if paranoid is enabled.

```js
const numberOfDeletedRecord = async (id) => {
  const numberOfDeletedRecord = await db.SimplePokemon.destroy({
    where: {
      id: 1
    }
  });
  return numberOfDeletedRecord;
};

// Truncate the table
await SimplePokemon.destroy({
  truncate: true
});
```

How do you return a deleted record?

## What is atomicity?

An atomic operation is an operation that ensures whatever it is editing is only currently edited by the operation. When you want to update a database record, atomicity means that the database record is locked (not available to other operations) until the database record is updated.

If we do not have atomicity and there are 2 operations to be runs at the same time (concurrent calls),
1. Update pokemon1 baseHP++
2. Update pokemon1 baseHP++
Both operations will find a pokemon with baseHP that is 4, then both will add 1 to `baseHP = 4` and update the baseHP of the same pokemon to `baseHP = 5`. The final baseHP will be 5 instead of 6.

Sequelize has built-in support for optimistic locking through a model instance version count.

Optimistic locking is **disabled by default** and can be enabled by setting the version property to true in a specific model definition or global model configuration. See [model definition](https://sequelize.org/v5/manual/models-definition.html#optimistic-locking). Optimistic locking allows concurrent access to model records for edits and prevents conflicts from overwriting data. It does this by checking whether another process has made changes to a record since it was read and throws an OptimisticLockError when a conflict is detected.

## FYI: Sequelize Convenience Methods for aggregations

Sequelize Model offers some convenient methods to support operations with query with database. Please read their documentation and [API Reference - Model](https://sequelize.org/master/class/lib/model.js~Model.html) for more.
- [findAndCountAll](https://sequelize.org/master/manual/model-querying-finders.html#-code-findandcountall--code-) : This is useful while we want to have paginated result.
- [Utility Methods](https://sequelize.org/master/manual/model-querying-basics.html#utility-methods) like `count`, `max`, `min`, `sum`

## FYI: Raw Query
As Sequelize offers good database abstraction to the developers and the the developers to be familiar with database dialect to dealing with raw queries, we are not covering this topic in the course.

The `sequelize.query` method returns a Promise, so that they can be used with async/await. It also allows you to map a query to a predefined model.

You could read [Raw Queries](https://sequelize.org/master/manual/raw-queries.html) for details.