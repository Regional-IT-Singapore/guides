# Postgres testing

## Mock database vs real database

If we are writing unit tests, by definition we need to mock the interaction with database and we don't depend on a real database.

For integration test/contract test (e.g. on web service built using Express + Postgres), we need to get the server up and running before we can send requests to it. Most of the time, that would require us to have a real database.

If somehow your tests need to depend on a real database, you need to make sure each test case has a clean database to start with. One solution is to set up and tear down all the tables in the database to ensure there are no side effects between unit tests. In practice, this means a `beforeEach()` where you reconnect to the database and drop all tables, and an `afterEach()` where you disconnect from the database.

Another solution is to set up an **in-memory database** for each test case programmatically to avoid some of the issues with setting up a real database and sharing one database with all tests.

## pg-mem

Usage of **in-memory database** offers us a clean/empty database for each test case, so that the test cases do not interfere with each other (e.g. if a test case fails and leave some garbage data in its copy of database, that failure will not affect other test cases because each test case starts with a clean database).

To write API integration tests for an Express app that uses Postgres as the database, we could choose to use `pg-mem` along with `jest` and `supertest`. It spins up an in-memory instance of a Postgres database, which is faster than running a separate Postgres instance. The library provides handy shortcuts to create instances of popular libraries that will be bound to pg-mem instead of a real postgres db.

Some of the popular library adapters that shipped with **pg-mem** includes:
- [node-postgres (pg)](https://github.com/oguimbal/pg-mem/wiki/Libraries-adapters#-node-postgres-pg)
- [TypeORM](https://github.com/oguimbal/pg-mem/wiki/Libraries-adapters#-typeorm)
- [Knex](https://github.com/oguimbal/pg-mem/wiki/Libraries-adapters#-knex)

Although there isn't any direct support for testing `sequelize` ORM with Postgres, we could extend the usage of `pg-mem` since sequelize is using `pg` as the underlying Postgres client.

## Unit/Integration Testing with Jest

For testing database, very often we will use `toMatchObject`. This is because the database objects will have the extra attribute `id`.
https://stackoverflow.com/questions/45692456/whats-the-difference-between-tomatchobject-and-objectcontaining

[Manual mocks](https://jestjs.io/docs/manual-mocks) are used to stub out functionality with mock data.

[Snapshots tests](https://jestjs.io/docs/snapshot-testing) are a fantastic tool for identifying unexpected interface changes within your application â€“ whether that interface is an API response, UI, logs, or error messages. Snapshot files are generated by Jest the first time it's running the test, and prevent accidental update of the test expectation. As with any testing strategy, there are some [best-practices](https://jestjs.io/docs/snapshot-testing#best-practices). The aim of snapshot testing is not to replace existing unit tests, but to provide additional value and make testing painless. Jest allows providing an asymmetric matcher `.toMatchSnapshot(propertyMatchers?, hint?)` for any property. We could use [Property Matchers](https://jestjs.io/docs/snapshot-testing#property-matchers) in the snapshot files to avoid failure due to generated fields.

## Exercises

Refer to [GitHub repo](https://github.com/ThoughtWorks-SEA/sequelize-basics-crud)

- Complete the unit test for SimplePokemon CRUD routes.
- Create integration testing with Sequelize Mock for SimplePokemon CRUD routes, to test business logic.
- Integrate Postgres into your testing for your song routes.
