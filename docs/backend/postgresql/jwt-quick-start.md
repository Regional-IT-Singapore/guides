## Lab: Quick start security-jwt

Let's create a new simple project to practice.

```bash
mkdir security-jwt
cd security-jwt
npm init -y
npm install express dotenv
npm install nodemon --save-dev
echo "node_modules" >> .gitignore
echo ".env" >> .gitignore
git init
```

You'll also need to create your `index.js` and `app.js` files.

Add the usual code necessary to start your server in these files (refer to your old practice projects!).

Remember to add your start scripts in your `package.json` file:

```js
"start": "node index.js",
"start:dev": "nodemon index.js",
```

Remember to add the default error handler in your app.js, so that we can pass on errors simply by using `next(err)` in a try...catch:

```js
app.use((err, req, res, next) => {
  err.statusCode = err.statusCode || 500;
  res.status(err.statusCode).send(err.message);
});
```

### Using cookies and same origin policy

For us to read cookies, we need `cookie-parser`.

```
npm install cookie-parser
```

In app.js, we use this middleware.

```js
// app.js
const cookieParser = require("cookie-parser");

app.use(cookieParser());
```

### Install json web token and bcryptjs

Install the star of the show, the token we will be creating and reading.

```
npm install jsonwebtoken
```

We shall use bcryptjs (which uses bcrypt) for hashing our passwords.

```
npm install bcryptjs
```

### Install Sequelize and Sequelize-CLI

```
npm install pg pg-hstore sequelize
```

We will also make use of `sequelize-cli` to help us generate the template for our Sequelize setup and run database migration for us. See: [Sequelize Migration](https://sequelize.org/master/manual/migrations.html)

```
npm install --save-dev sequelize-cli
```

### Sequelize Configuration for Migration and Application

A typical project which use `sequelize-cli` has four subdirectories: **config, migrations, models, and seeders**. See: [Project bootstraping](https://sequelize.org/master/manual/migrations.html#project-bootstrappAing).

For better code organisation, we will create a folder `config` to store all our configuration (including database) and maintain a folder `db` to store all the files generated by `sequelize-cli`.
We will also create the config file manually instead of using the sequelize-cli generator as we prefer a `.js` setup file instead of a `.json` file for the [dynamic configuration](https://sequelize.org/master/manual/migrations.html#dynamic-configuration). A .`js` file allows us to refer to environment variables.

For details, here are the explanation for the configuration file and generated files for `sequelize-cli`, following our recommended code organisation.

| Folder/File          | Type            | For Migration | For Application | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| :------------------- | :-------------- | :------------ | :-------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `config/database.js` | create manually | Yes           | Yes             | For migration and application to connect to database.                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `db/models.js`       | generated       | No            | Yes             | For application to create database tables. The boilerplate for these files are generated by commands `sequelize-cli model:generate`. These files **need to be updated manually** to reflect our data models expectation.                                                                                                                                                                                                                                                                    |
| `db/migrations.js`   | generated       | Yes           | No              | For migration to create the database tables and update the database columns. The boilerplate for these files are generated by commands `sequelize-cli model:generate` (for create) and `sequelize-cli migration:generate` (for update). These files **need to be updated manually** to reflect our updated database table definition. Please see [Migration Skeleton](https://sequelize.org/master/manual/migrations.html#migration-skeleton) for how to define the files for actual usage. |
| `db/seeders.js`      | generated       | Yes           | No              | For data migration, eg. populate dattabase table with sample data or test data. The boilerplate for these files are generated by commands `sequelize-cli seed:generate`. These files **need to be updated manually** to reflect our data models expectation.                                                                                                                                                                                                                                |

**Let's begin our set up for Sequelize Migration (Database Table Definition) and Sequelize (App Usage)**

1. create the config folder in the root folder
2. create a database.js file with the content below in the config folder
3. replace the username and password with the credentials for your postgres server. For the sake of this course, we will use `postgres` as the migration user.
4. replace the database key with the database name you prefer

```js
// config/database.js

module.exports = {
  development: {
    // replace the `username` and `password` with the credentials for your postgres server
    username: "postgres",
    password: null,
    database: "database_development",
    host: "127.0.0.1",
    dialect: "postgres",
  },
  test: {
    // replace the `username` and `password` with the credentials for your postgres server
    username: "postgres",
    password: null,
    database: "database_test",
    host: "127.0.0.1",
    dialect: "postgres",
  },
  production: {
    username: process.env.PG_USER,
    password: process.env.PG_PASS,
    database: process.env.PG_DB_NAME,
    host: process.env.PG_HOST,
    port: process.env.PG_PORT,
    dialect: "postgres",
  },
};
```

**Set up Sequelize directory config**

This file is not generated by default, it is used to pass arguments to the `sequelize-cli` to run database migrations. However, it's recommended to create this file as follow. We are overwriting the default path of sequelize folders to customize the folder hierarchies. _When we share a codebase for database migration and application usage, the default paths for the generated files by sequelize-cli could be very confusing._

Steps:

1. Create an empty `.sequelizerc` file at the project root directory
2. Copy the following code for the recommended code organisation.

```js
// .sequelizerc

const path = require("path");

module.exports = {
  config: path.resolve("config", "database.js"),
  "models-path": path.resolve("db", "models"),
  "seeders-path": path.resolve("db", "seeders"),
  "migrations-path": path.resolve("db", "migrations"),
};
```

**Create the database using Sequelize CLI**

In this example, we are using `npx` to run sequelize-cli's `sequelize` package with the command `db:create`.
Without `npx`, you will need to refer to the full node_modules path when running any commands from the sequelize-cli package

Let's create a database in the development environment with the name stated in the config file:

```
npx sequelize db:create
```

- By default, the command will run against the development environment.
- To change the environment to run against, prepend the NODE_ENV to the command. E.g. `NODE_ENV=test npx sequelize db:create`

If it says `permission denied`, you may need to alter the role of the postgres user that you are using `ALTER USER <username> SUPERUSER`, for example:

```
$ psql

// check list of roles and their permissions
// the default user on your machine will already have all the Superuser permissions by default
user=# \du

List of roles
    Role name    |                         Attributes                         | Member of
-----------------+------------------------------------------------------------+-----------
 postgres        |                                                            | {}
 sabrina         | Superuser, Create role, Create DB, Replication, Bypass RLS | {}

// make user "postgres" a superuser
user=# ALTER USER postgres SUPERUSER;
ALTER ROLE

user=# \du

List of roles
    Role name    |                         Attributes                         | Member of
-----------------+------------------------------------------------------------+-----------
 postgres        | Superuser                                                  | {}
 sabrina         | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
```

**Initialize Folders for Sequelize CLI**

These commands will generate the folder, based on your `.sequelizerc` configuration.

```bash
# To store database migration scripts
npx sequelize init:migrations

# To store models definition, and index.js for model reference in the application.
npx sequelize init:models

# For advanced usage
npx sequelize init:config
npx sequelize init:seeders
```

Once you are done with this step, a file `db/models/index.js` will be automatically generated to initiatialise all the models during NodeJS application start up.
You could access the following through the `db` variable exported from the boilerplate codes in `db/models/index.js`.
The variable `db` will also be the common gate to link up the associated models.

```js
// app.js
const db = require('./db/models');
const Trainer = require();

// To synchronise the database table with models. This will create the database table for new models if absence.
// Other synchronisation have tendency to cause destructive operations to the existing data.
// For Production, we should consider on DB migration and expect no modification to database table during the application start up.
const dbConnection = db.sequelize;
db.sequelize.sync();

// To access your defined models.
const Trainer = db.Trainer;
```

At the point of writing, the data models generated need some manual fix for undefined variable `Sequelize` (default export) vs `DataTypes` (named export) which are exported from `sequelize` module.
You will need to adjust the models, migration and seeding scripts to fit your needs. See: [Query Interface](https://sequelize.org/master/class/lib/dialects/abstract/query-interface.js~QueryInterface.html).

### Create a Trainer model with username and password

Run these commands in the terminal:

```bash
// Generate a trainer model
npx sequelize model:generate --name Trainer --attributes username:string,password:string
```

Take note that this generation script will create 2 files: a model class file, and a migration file.

```bash
New model was created at security-jwt/models/trainer.js .
New migration was created at security-jwt/migrations/20210823035441-create-trainer.js .
```

### Updating the Trainer migration file

A database migration system captures every single changes to the database.

It is used to keep the states of the database in every environment in sync.
For example, here are some common issues faced with syncing database states

1. Production tables should not be dropped, changes should be added incrementally
   - We create a migration file that adds a new column to an existing table and let sequelize migration handles the updating of states
1. Production database's state is different and lag behind development's database
   - We can easily test if the new database changes will cause a conflict to the existing production state by running migrations
   - Migration files also keep track of the individual schema changes in the codebase

Let's go ahead and add the unique and allowNull keys to keep the migration file behavior in sync with the model file.

```js
"use strict";

module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable("Trainers", {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      username: {
        type: Sequelize.STRING,
        allowNull: false, // here
        unique: true,
      },
      password: {
        type: Sequelize.STRING,
        allowNull: false, // here
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE,
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE,
      },
    });
  },
  down: async (queryInterface, Sequelize) => {
    await queryInterface.dropTable("Trainers");
  },
};
```

### Running the Trainer migration file

Important difference between migrations and models

- Migration keep track of the changes and running migrations make the changes to the database directly.
- Models represent the database tables by mapping it into an object we can refer to in the codebase

Run this command to create the Trainer table in your database
`npx sequelize db:migrate`

- Running this command multiple times will not cause any conflicts as it will only run new migration files once
- Sequelize knows which migration files are new as it keeps track of database states with the metadata captured from each migration

**A Tip for migration is to always make sure changes to a database state can be undo and redo without breaking anything**

So it is a good practice to try the rollback/undo script when testing your migration scripts

```
npx sequelize db:migrate
npx sequelize db:migrate:undo
npx sequelize db:migrate
```

### Connect and initialise database for the main app

app.js

```js
const express = require("express");
const cookieParser = require("cookie-parser");
const db = require("./models/index");

// sync will make sure the that the database is connected and the models are properly setup on app startup
db.sequelize.sync();

const app = express();
app.use(cookieParser());

app.use(express.json());

module.exports = app;
```

### New trainer route for creating a new Trainer

routes/trainers.js

```js
const express = require("express");
const db = require("../models/index");

const router = express.Router();

// Add POST /trainers route
router.post("/", async (req, res) => {
  try {
    const newTrainer = await db.Trainer.create(req.body);
    res.send(newTrainer);
  } catch (err) {
    console.error(err);
    next(err);
  }
});

module.exports = router;
```

### Add trainer route to app.js

Add trainer route before the exporting the app function

```js
const trainersRouter = require("./routes/trainers.js");
app.use("/trainers", trainersRoutes);
```

index.js

```js
const app = require("./app");

const PORT = process.env.PORT || 4000;

app.listen(PORT, () => {
  console.log(`Server started on port ${PORT}...`);
});
```

#### Test if setup is working correctly

Using [Postman](https://www.postman.com/downloads/), try to create a Trainer through the `POST` method and `http://localhost:XXXX/trainers` request URL.

You should also include some data in the body (body -> raw -> JSON), e.g.:

```json
{
  "username": "ash3",
  "password": "iWannaB3DVeryBest"
}
```

I can create trainers now! Note that the hash is different even for same passwords. This is thanks to the salting of bcrypt.

### Generating a JWT secret

<!-- WIP -->

How to generate a good `JWT_SECRET_KEY`? Because we use HS256 algoithm for the signature, we should have a 256 bits key of 32 characters.

You can generate a good random 256 bits key (crypographically strong pseudorandom) with

```sh
node -e "console.log(require('crypto').randomBytes(256 / 8).toString('hex'));"
```

You can also generate a base64 key with:

```sh
node -e "console.log(require('crypto').randomBytes(256 / 8).toString('base64'));"
```

If you choose to use a base64 key, read the key into a Buffer using `Buffer.from(key, "base64")` and use it with `jwt.sign` and `jwt.verify`.

Save it in `.env` file and do not commit it. Remember to add the `.env` file to `.gitignore`.

```
JWT_SECRET_KEY=udhwhd89237er8hejkfnekf28ynf2397r5983tryn938gh34589
```

### Generating a JWT token and finding the secret

- Create a `jwt.js` file inside the config folder, with the `getJWTSecret` function.

config/jwt.js

```js
const jwt = require("jsonwebtoken");

const getJWTSecret = () => {
  const secret = process.env.JWT_SECRET_KEY;
  if (!secret) {
    throw new Error("Missing secrets to sign JWT token");
  }
  return secret;
};

const createJWTToken = (username) => {
  const today = new Date();
  const exp = new Date(today);

  const secret = getJWTSecret();
  exp.setDate(today.getDate() + 60); // adding days

  const payload = { username: username, exp: parseInt(exp.getTime() / 1000) };
  const token = jwt.sign(payload, secret);
  return token;
};

module.exports = createJWTToken;
```

For your tests and your code to be able to find the `JWT_SECRET_KEY`, you can load the environment variables using `dotenv` in **app.js**.

Place this line at the top of your app.js:

```js
require("dotenv").config();
```

#### More on the exp field in the JWT payload

In the example above, the expiration date of the JWT token is set to 60 days later after it's generated. Then the expiration time is saved into the exp field of the JWT token.

What is this exp field? Why must I use this term?

It represents **Token Expiration,** and you can find [more details here](https://www.npmjs.com/package/jsonwebtoken#token-expiration-exp-claim).

Once this field is set in a token, it's validated later on when we call the jwt.verify(token, secret). A token that passes the expiration time will fail the verification.

### Protect a route

Now that we have our `JWT_SECRET_KEY` set up, let's create a `protectRoute` middleware:

middleware/protectRoute.js

```js
const jwt = require("jsonwebtoken");

const protectRoute = (req, res, next) => {
  try {
    if (!req.cookies.token) {
      throw new Error("You are not authorized");
      /* Alternatively, you can set a default error handler in app.js instead and do this:
        const err = new Error("You are not authorized");
        next(err);
      */
    } else {
      //`req.cookies` is populated by the `cookie-parser` middleware.
      req.user = jwt.verify(req.cookies.token, process.env.JWT_SECRET_KEY);
      next();
    }
  } catch (err) {
    err.statusCode = 401;
    next(err);
  }
};

module.exports = {
  protectRoute,
};
```

To add the feature of allowing users to search for a trainer by their username, add a new GET /trainers/:username route:

routes/trainers.js

```js
router.get("/:username", async (req, res, next) => {
  try {
    const username = req.params.username;
    // [db.Sequelize.Op.iLike] allows you to do case-insensitive querying
    const trainer = await db.Trainer.findOne({
      where: { username: { [db.Sequelize.Op.iLike]: "%" + username + "%" } },
    });
    res.send(trainer);
  } catch (err) {
    console.error(err);
    next(err);
  }
});
```

1. Create a Trainer with username and password, using POST /trainers
1. You should be able to GET the trainer using /trainers/:username

What if we only want authenticated users to access this endpoint?

We can protect the endpoint by using the `protectRoute` middleware we created earlier:

```js
const { protectRoute } = require("../middleware/protectRoute");

router.get("/:username", protectRoute, async (req, res, next) => {
  try {
    const username = req.params.username;
    const trainer = await db.Trainer.findOne({
      where: { username: { [db.Sequelize.Op.iLike]: "%" + username + "%" } },
    });
    res.send(trainer);
  } catch (err) {
    console.error(err);
    next(err);
  }
});
```

Now, try making a call to `GET /trainers/:username` again.

You should see an error: "You are not authorized". In order to be authorised, the request needs to have a cookie with a valid token in the headers. That's where our `/login` API comes in:

### Login and logout

Read documentation about `res.cookie` and `res.clearCookie`:

- http://expressjs.com/en/api.html#res.cookie
- http://expressjs.com/en/api.html#res.clearCookie

```js
const bcrypt = require("bcryptjs");
const createJWTToken = require("../config/jwt");

router.post("/login", async (req, res, next) => {
  try {
    const { username, password } = req.body;
    const trainer = await db.Trainer.findOne({
      where: { username: { [db.Sequelize.Op.iLike]: "%" + username + "%" } },
    });

    // return if Trainer does not exist
    // message returned is intentionally vague for security reasons
    if (!trainer) {
      return res.status(422).json({ message: "Invalid username or password." });
    }

    // check if user input password matches hashed password in the db
    const result = await bcrypt.compare(password, trainer.password);

    if (!result) {
      throw new Error("Login failed");
    }

    const token = createJWTToken(trainer.username);

    // calculation to determine expiry date - this is up to your team to decide
    const oneDay = 24 * 60 * 60 * 1000;
    const oneWeek = oneDay * 7;
    const expiryDate = new Date(Date.now() + oneWeek);

    // you are setting the cookie here, and the name of your cookie is `token`
    res.cookie("token", token, {
      expires: expiryDate,
      httpOnly: true, // client-side js cannot access cookie info
      secure: true, // use HTTPS
    });

    res.send("You are now logged in!");
  } catch (err) {
    if (err.message === "Login failed") {
      err.statusCode = 400;
    }
    next(err);
  }
});

router.post("/logout", (req, res) => {
  // clears the 'token' cookie from your browser
  res.clearCookie("token").send("You are now logged out!");
});
```

Log in with a valid trainer now and check the **Headers**. You should see a `Set-Cookie` key, with a value that looks something like: `token=eyJhbGciOiJIUzI1NsdsaCI6IkpXVCJ9.eyJuYW1lIjoiYasdhZG1pbiIsImV4cCI6MTYxOTc3MdaWF0IjoxNjE0NTg5Mzg5fQ.NYH7deb9asdpH4i3SSR0ic7DF3USv2xiGwVq6L-xiZM; Path=/; Expires=Mon, 08 Mar 2021 09:03:09 GMT; HttpOnly; Secure`.

Now that you have this token, go ahead and try calling `GET /trainers/:username` again. But before you submit the request, set the headers with a key `Cookie`, and copy paste the value of the entire string of the token. You should now be able to retrieve the user details of the specified username!
